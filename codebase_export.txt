TankGame

ROOT:
	codebase.gd
	codebase_export.txt
	ground_texture.png
	icon.svg
	level_template.tscn
	project.godot
_______________
(level_template.gd):
extends Node2D

@onready var cam : Camera2D = $Tank/Camera2D

func _ready() -> void:
	var cb = CodebaseExporter.new()
	cb.export_codebase_to_file()
	

#func _input(event: InputEvent) -> void:
	#if event.is_action_pressed("ui_left", true):
		#cam.translate(Vector2(-10,0))
	#if event.is_action_pressed("ui_right", true):
		#cam.translate(Vector2(10,0))
	#if event.is_action_pressed("ui_down", true):
		#cam.translate(Vector2(0,10))
	#if event.is_action_pressed("ui_up", true):
		#cam.translate(Vector2(0,-10))
	#pass

_______________
_______________
(tank.gd):
extends CharacterBody2D
class_name Tank

# Movement settings
@export var move_speed : float = 300.0
@export var gravity : float = 980.0
@export var rotation_speed : float = 2.0  # How fast tank aligns to terrain

@onready var right_ray  : RayCast2D = $RayCastRight
@onready var center_ray : RayCast2D =  $RayCastCenter
@onready var left_ray  : RayCast2D = $RayCastLeft

@onready var collision_shape : CollisionShape2D = $CollisionShape2D

@export var body_sprite : Sprite2D
@export var left_wheel : Sprite2D
@export var right_wheel : Sprite2D

var rotation_divisor = 500.0

func _ready() -> void:
	if body_sprite:
		adjust_collision_bounds(body_sprite.texture)

func adjust_collision_bounds(body_texture : Texture2D):
	(collision_shape.shape as RectangleShape2D).size = body_texture.get_size()

func _physics_process(delta: float):
	# Apply gravity
	if not is_on_floor() or !center_ray.is_colliding():
		velocity.y += gravity * delta
	
	# Handle input
	var direction = 0
	if Input.is_action_pressed("move_left"):
		direction = -1
	elif Input.is_action_pressed("move_right"):
		direction = 1
	
	# Move along the tank's forward direction (accounting for slope)
	if direction != 0:
		if !center_ray.is_colliding():
			if !right_ray.is_colliding() and direction > 0:
				rotate(TAU/rotation_divisor)
			if !left_ray.is_colliding() and direction < 0:
				rotate(-TAU/rotation_divisor)
			rotation_divisor -= 10.0
		else:
			rotation_divisor = 500.0
		var forward = Vector2(direction, 0).rotated(rotation)
		velocity.x = forward.x * move_speed
		velocity.y = forward.y * move_speed
		
		# Rotate wheels visually
		if left_wheel:
			left_wheel.rotation -= direction * delta * 5
		if right_wheel:
			right_wheel.rotation -= direction * delta * 5
	else:
		#if !center_ray.is_colliding():
			#if !right_ray.is_colliding() and left_ray.is_colliding():
				#rotate(TAU/rotation_divisor)
			#if !left_ray.is_colliding() and right_ray.is_colliding():
				#rotate(-TAU/rotation_divisor)
			#rotation_divisor -= 10.0
		#else:
			#rotation_divisor = 500.0
		velocity.x = move_toward(velocity.x, 0, move_speed * delta)
	
	# Align to terrain
	align_to_terrain(delta)
	
	# Move and slide
	move_and_slide()

func align_to_terrain(delta: float):
	var left_hit = left_ray.is_colliding()
	var center_hit = center_ray.is_colliding()
	var right_hit = right_ray.is_colliding()
	
	# Get hit points for grounded rays
	var left_point = left_ray.get_collision_point() if left_hit else Vector2.ZERO
	var right_point = right_ray.get_collision_point() if right_hit else Vector2.ZERO
	
	# Case 1: Both wheels on ground - align to slope
	if left_hit and right_hit:
		var angle = (right_point - left_point).angle()
		rotation = lerp_angle(rotation, angle, rotation_speed * delta)
	
	# Case 2: Only left wheel grounded - rotate clockwise
	elif left_hit and not right_hit and not center_hit:
		rotation += rotation_speed * delta
	
	# Case 3: Only right wheel grounded - rotate counter-clockwise
	elif right_hit and not left_hit and not center_hit:
		rotation -= rotation_speed * delta
	
	# Case 4: Center and one wheel (on hill peak) - stay put
	elif center_hit and (left_hit or right_hit):
		# Tank is balanced on peak, don't rotate
		pass
	
	# Optional: Adjust vertical position to stay on ground
	if left_hit or right_hit or center_hit:
		var lowest_point = INF
		if left_hit:
			lowest_point = min(lowest_point, left_ray.get_collision_point().y - global_position.y)
		if right_hit:
			lowest_point = min(lowest_point, right_ray.get_collision_point().y - global_position.y)
		if center_hit:
			lowest_point = min(lowest_point, center_ray.get_collision_point().y - global_position.y)
		
		# Snap to ground if very close
		if lowest_point < 5 and lowest_point > -5:
			position.y += lowest_point

func get_aim_angle() -> float:
	# For aiming your weapon later
	return rotation

_______________
_______________
(terrain.gd):
extends Node2D
@onready var poly : Polygon2D = $Polygon2D
@onready var body : StaticBody2D = $Polygon2D/StaticBody2D
@onready var body_coll : CollisionPolygon2D = $Polygon2D/StaticBody2D/CollisionPolygon2D
@export var noise1 : FastNoiseLite = FastNoiseLite.new()
@export var noise2 : FastNoiseLite = FastNoiseLite.new()
var base_ground_level = 1200.0
var slope_range = 100.0

func _ready() -> void:
	var points : PackedVector2Array = []
	points.append(Vector2(-3000, base_ground_level * 4))
	for i in range(-3000, 3000, 10):
		points.append(Vector2(i, base_ground_level + (slope_range * (noise1.get_noise_1d(i)+noise2.get_noise_1d(i)))))
	points.append(Vector2(3000, base_ground_level * 4))
	poly.polygon = points
	body_coll.polygon = points

_______________
